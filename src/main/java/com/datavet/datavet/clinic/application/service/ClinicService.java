package com.datavet.datavet.clinic.application.service;

import com.datavet.datavet.clinic.application.port.in.command.CreateClinicCommand;
import com.datavet.datavet.clinic.application.port.in.ClinicUseCase;
import com.datavet.datavet.clinic.application.port.in.command.UpdateClinicCommand;
import com.datavet.datavet.clinic.application.port.out.ClinicRepositoryPort;
import com.datavet.datavet.clinic.application.validation.CreateClinicCommandValidator;
import com.datavet.datavet.clinic.application.validation.UpdateClinicCommandValidator;
import com.datavet.datavet.clinic.domain.exception.ClinicAlreadyExistsException;
import com.datavet.datavet.clinic.domain.exception.ClinicNotFoundException;
import com.datavet.datavet.clinic.domain.exception.ClinicValidationException;
import com.datavet.datavet.clinic.domain.model.Clinic;
import com.datavet.datavet.shared.application.service.ApplicationService;
import com.datavet.datavet.shared.domain.event.DomainEvent;
import com.datavet.datavet.shared.domain.event.DomainEventPublisher;
import com.datavet.datavet.shared.domain.validation.ValidationResult;
import com.datavet.datavet.shared.domain.valueobject.Address;
import com.datavet.datavet.shared.domain.valueobject.Email;
import com.datavet.datavet.shared.domain.valueobject.Phone;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
@RequiredArgsConstructor
public class ClinicService implements ClinicUseCase, ApplicationService {

    private final ClinicRepositoryPort clinicRepositoryPort;
    private final CreateClinicCommandValidator createClinicCommandValidator;
    private final UpdateClinicCommandValidator updateClinicCommandValidator;
    private final DomainEventPublisher domainEventPublisher;
    


    @Override
    public Clinic createClinic(CreateClinicCommand command) {
        // Validate command using shared validation framework
        ValidationResult validationResult = createClinicCommandValidator.validate(command);
        if (validationResult.hasErrors()) {
            throw new ClinicValidationException(validationResult);
        }
        
        // Check for duplicate email (value object is already created in command)
        if (clinicRepositoryPort.existsByEmail(command.getEmail())) {
            throw new ClinicAlreadyExistsException("email", command.getEmail().getValue());
        }
        
        // Check for duplicate legal number
        if (clinicRepositoryPort.existsByLegalNumber(command.getLegalNumber())) {
            throw new ClinicAlreadyExistsException("legalNumber", command.getLegalNumber());
        }
        
        // Use factory method to create clinic with domain events
        Clinic clinic = Clinic.create(
                null, // ID will be generated by database
                command.getClinicName(),
                command.getLegalName(),
                command.getLegalNumber(),
                command.getAddress(),
                command.getPhone(),
                command.getEmail(),
                command.getLogoUrl(),
                "ACTIVE"
        );
        
        // Publish domain events BEFORE saving (while we still have them)
        publishDomainEvents(clinic);
        
        Clinic savedClinic = clinicRepositoryPort.save(clinic);
        
        return savedClinic;
    }

    @Override
    public Clinic updateClinic(UpdateClinicCommand command) {
        // Validate command using shared validation framework
        ValidationResult validationResult = updateClinicCommandValidator.validate(command);
        if (validationResult.hasErrors()) {
            throw new ClinicValidationException(validationResult);
        }
        
        Clinic existing = clinicRepositoryPort.findById(command.getClinicId())
                .orElseThrow(() -> new ClinicNotFoundException(command.getClinicId()));

        // Check for duplicate email (excluding current clinic) - value object is already created in command
        if (clinicRepositoryPort.existsByEmailAndIdNot(command.getEmail(), command.getClinicId())) {
            throw new ClinicAlreadyExistsException("email", command.getEmail().getValue());
        }

        // Use domain method to update clinic with domain events
        existing.update(
                command.getClinicName(),
                command.getLegalName(),
                command.getLegalNumber(),
                command.getAddress(),
                command.getPhone(),
                command.getEmail(),
                command.getLogoUrl(),
                command.getSuscriptionStatus()
        );

        // Publish domain events BEFORE saving
        publishDomainEvents(existing);
        
        Clinic savedClinic = clinicRepositoryPort.save(existing);
        
        return savedClinic;
    }

    @Override
    public void deleteClinic(Long id) {
        Clinic clinic = getClinicById(id); // This will throw if not found
        clinic.delete(); // This creates the domain event
        
        // Publish domain events BEFORE deleting
        publishDomainEvents(clinic);
        
        clinicRepositoryPort.deleteById(id);
    }

    @Override
    public Clinic getClinicById(Long id) {
        return clinicRepositoryPort.findById(id).orElseThrow(() -> new ClinicNotFoundException(id));
    }

    @Override
    public List<Clinic> getAllClinics() {
        return clinicRepositoryPort.findAll();
    }
    
    /**
     * Publishes all domain events from the aggregate and clears them.
     */
    private void publishDomainEvents(Clinic clinic) {
        List<DomainEvent> events = clinic.getDomainEvents();
        for (DomainEvent event : events) {
            domainEventPublisher.publish(event);
        }
        clinic.clearDomainEvents();
    }
}